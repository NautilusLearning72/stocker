import { Component, Input } from '@angular/core';
import { CommonModule } from '@angular/common';
import { MatCardModule } from '@angular/material/card';
import { MatIconModule } from '@angular/material/icon';
import { MatProgressSpinnerModule } from '@angular/material/progress-spinner';
import { MatTooltipModule } from '@angular/material/tooltip';

import { MetricsSummary as MetricsSummaryData } from '../../../core/services/metrics.service';

interface SummaryCard {
  label: string;
  value: number | string;
  icon: string;
  tooltip: string;
  colorClass: string;
}

@Component({
  selector: 'app-metrics-summary',
  standalone: true,
  imports: [
    CommonModule,
    MatCardModule,
    MatIconModule,
    MatProgressSpinnerModule,
    MatTooltipModule,
  ],
  templateUrl: './metrics-summary.html',
  styleUrl: './metrics-summary.scss',
})
export class MetricsSummary {
  @Input() summary: MetricsSummaryData | null = null;
  @Input() loading = false;

  get cards(): SummaryCard[] {
    if (!this.summary) return [];

    return [
      {
        label: 'Total Events',
        value: this.summary.total_events.toLocaleString(),
        icon: 'event_note',
        tooltip: 'Total number of events recorded in the selected time period',
        colorClass: 'default',
      },
      {
        label: 'Orders Created',
        value: this.summary.orders_created,
        icon: 'shopping_cart',
        tooltip: 'Number of new orders generated by the trading system',
        colorClass: 'success',
      },
      {
        label: 'Orders Skipped',
        value: this.summary.orders_skipped,
        icon: 'block',
        tooltip: 'Orders that were not placed due to minimum size, risk controls, or other filters',
        colorClass: this.summary.orders_skipped > 0 ? 'warning' : 'default',
      },
      {
        label: 'Confirmation Rate',
        value: this.summary.confirmation_rate !== null
          ? `${(this.summary.confirmation_rate * 100).toFixed(1)}%`
          : 'N/A',
        icon: 'verified',
        tooltip: 'Percentage of signals that passed confirmation checks (Donchian/MA) before becoming orders',
        colorClass: 'default',
      },
      {
        label: 'Trailing Stops',
        value: this.summary.trailing_stops_triggered,
        icon: 'trending_down',
        tooltip: 'Number of positions automatically closed when price dropped too far from peak (protects profits)',
        colorClass: this.summary.trailing_stops_triggered > 0 ? 'warning' : 'default',
      },
      {
        label: 'Sector Caps',
        value: this.summary.sector_caps_applied,
        icon: 'pie_chart',
        tooltip: 'Times a position was reduced to stay within sector concentration limits (prevents over-exposure to one industry)',
        colorClass: this.summary.sector_caps_applied > 0 ? 'info' : 'default',
      },
      {
        label: 'Correlation Throttles',
        value: this.summary.correlation_throttles,
        icon: 'compare_arrows',
        tooltip: 'Times a new position was limited because it moves similarly to stocks you already own (prevents hidden concentration)',
        colorClass: this.summary.correlation_throttles > 0 ? 'info' : 'default',
      },
    ];
  }

  get categoryBreakdown(): { category: string; count: number }[] {
    if (!this.summary?.by_category) return [];
    return Object.entries(this.summary.by_category)
      .map(([category, count]) => ({ category, count }))
      .sort((a, b) => b.count - a.count);
  }

  getMetrics() {
    if (!this.summary) return [];

    return [
      {
        label: 'Total Events',
        value: this.summary.total_events.toLocaleString(),
        help: 'Total number of events in the selected time period'
      },
      {
        label: 'Orders Created',
        value: this.summary.orders_created,
        badge: 'success',
        badgeText: 'âœ“',
        help: 'Orders successfully created and submitted'
      },
      {
        label: 'Orders Skipped',
        value: this.summary.orders_skipped,
        badge: this.summary.orders_skipped > 0 ? 'warning' : null,
        badgeText: '!',
        help: 'Orders skipped due to various constraints'
      },
      {
        label: 'Confirmation Rate',
        value: this.summary.confirmation_rate !== null
          ? `${(this.summary.confirmation_rate * 100).toFixed(1)}%`
          : 'N/A',
        help: 'Percentage of signals that passed confirmation'
      },
      {
        label: 'Trailing Stops',
        value: this.summary.trailing_stops_triggered,
        badge: this.summary.trailing_stops_triggered > 0 ? 'warning' : null,
        badgeText: '!',
        help: 'Number of trailing stop exits triggered'
      },
      {
        label: 'Sector Caps',
        value: this.summary.sector_caps_applied,
        help: 'Positions limited by sector exposure caps'
      },
      {
        label: 'Correlation Throttles',
        value: this.summary.correlation_throttles,
        help: 'Positions throttled due to correlation limits'
      }
    ];
  }

  getCategories() {
    if (!this.summary?.by_category) return [];

    const categoryMap: Record<string, { name: string; type: string }> = {
      signal: { name: 'Signals', type: 'primary' },
      exit: { name: 'Exits', type: 'warning' },
      diversification: { name: 'Diversification', type: 'default' },
      order: { name: 'Orders', type: 'success' },
      risk: { name: 'Risk Management', type: 'danger' },
      pipeline: { name: 'Pipeline', type: 'default' }
    };

    return Object.entries(this.summary.by_category).map(([key, count]) => ({
      ...(categoryMap[key] || { name: key, type: 'default' }),
      count
    }));
  }
}
