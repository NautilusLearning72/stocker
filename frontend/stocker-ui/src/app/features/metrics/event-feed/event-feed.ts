import { Component, Input, Output, EventEmitter, OnInit } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';
import { MatTableModule } from '@angular/material/table';
import { MatIconModule } from '@angular/material/icon';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatSelectModule } from '@angular/material/select';
import { MatInputModule } from '@angular/material/input';
import { MatButtonModule } from '@angular/material/button';
import { MatProgressSpinnerModule } from '@angular/material/progress-spinner';
import { MatTooltipModule } from '@angular/material/tooltip';

import { MetricEvent, MetricsService, MetricsCategories } from '../../../core/services/metrics.service';
import { SymbolLink } from '../../../shared/components/symbol-link/symbol-link';

@Component({
  selector: 'app-event-feed',
  standalone: true,
  imports: [
    CommonModule,
    FormsModule,
    MatTableModule,
    MatIconModule,
    MatFormFieldModule,
    MatSelectModule,
    MatInputModule,
    MatButtonModule,
    MatProgressSpinnerModule,
    MatTooltipModule,
    SymbolLink,
  ],
  templateUrl: './event-feed.html',
  styleUrl: './event-feed.scss',
})
export class EventFeed implements OnInit {
  @Input() events: MetricEvent[] = [];
  @Input() loading = false;
  @Input() isLive = false;

  @Output() filtersChanged = new EventEmitter<any>();

  displayedColumns = ['timestamp', 'category', 'event_type', 'symbol', 'value', 'details'];

  // Filter state
  categories: MetricsCategories | null = null;
  selectedCategory = '';
  selectedEventType = '';
  symbolFilter = '';
  eventTypeOptions: string[] = [];

  // Beginner-friendly descriptions
  categoryDescriptions: Record<string, string> = {
    signal: 'Trading signals generated by the strategy',
    exit: 'Position exits triggered by stop-loss or other rules',
    diversification: 'Portfolio diversification limits being applied',
    order: 'Order creation and sizing decisions',
    risk: 'Risk management controls activated',
    pipeline: 'Data processing pipeline events',
  };

  eventDescriptions: Record<string, string> = {
    signal_generated: 'A new trading signal was created based on trend analysis',
    confirmation_check: 'Signal was checked against confirmation filters (Donchian/MA)',
    trailing_stop_triggered: 'Position closed because price dropped too far from its peak',
    atr_exit_triggered: 'Position closed because price moved too far against entry',
    persistence_blocked: 'Signal flip was delayed - waiting for confirmation',
    sector_cap_applied: 'Position reduced to maintain sector diversification limit',
    asset_class_cap_applied: 'Position reduced to maintain asset class limit',
    correlation_throttle: 'Position limited due to high correlation with existing holdings',
    sizing: 'Order size was calculated based on volatility target',
    skipped: 'Order was not placed (too small or blocked by risk controls)',
    created: 'Order was created and sent to broker',
    single_cap_applied: 'Position reduced to stay within single-stock limit',
    gross_exposure_scaled: 'All positions scaled down due to total exposure limit',
    drawdown_scaling: 'Positions reduced due to portfolio drawdown',
    kill_switch_triggered: 'Trading halted - daily loss exceeded threshold',
    batch_processed: 'A batch of data was processed',
  };

  constructor(private metricsService: MetricsService) {}

  ngOnInit(): void {
    this.loadCategories();
  }

  loadCategories(): void {
    this.metricsService.getCategories().subscribe({
      next: (data) => {
        this.categories = data;
      },
      error: (err) => console.error('Failed to load categories:', err)
    });
  }

  onCategoryChange(): void {
    this.selectedEventType = '';
    if (this.selectedCategory && this.categories?.categories) {
      this.eventTypeOptions = this.categories.categories[this.selectedCategory] || [];
    } else {
      this.eventTypeOptions = [];
    }
    this.emitFilters();
  }

  onEventTypeChange(): void {
    this.emitFilters();
  }

  onSymbolFilterChange(): void {
    this.emitFilters();
  }

  clearFilters(): void {
    this.selectedCategory = '';
    this.selectedEventType = '';
    this.symbolFilter = '';
    this.eventTypeOptions = [];
    this.emitFilters();
  }

  private emitFilters(): void {
    this.filtersChanged.emit({
      category: this.selectedCategory || undefined,
      event_type: this.selectedEventType || undefined,
      symbol: this.symbolFilter || undefined,
    });
  }

  getCategoryClass(category: string): string {
    return `cat-${category}`;
  }

  getEventDescription(eventType: string): string {
    return this.eventDescriptions[eventType] || eventType.replace(/_/g, ' ');
  }

  getCategoryDescription(category: string): string {
    return this.categoryDescriptions[category] || '';
  }

  formatTimestamp(timestamp: string): string {
    const date = new Date(timestamp);
    return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });
  }

  formatDate(timestamp: string): string {
    const date = new Date(timestamp);
    return date.toLocaleDateString([], { month: 'short', day: 'numeric' });
  }

  formatValue(value: number | null): string {
    if (value === null || value === undefined) return '-';
    if (value === 0 || value === 1) return value.toString();
    if (Math.abs(value) < 1 && value !== 0) {
      return `${(value * 100).toFixed(1)}%`;
    }
    return value.toLocaleString(undefined, { maximumFractionDigits: 2 });
  }

  formatMetadata(metadata: Record<string, any>): string {
    if (!metadata || Object.keys(metadata).length === 0) return '-';
    const keys = Object.keys(metadata).slice(0, 2);
    return keys.map(k => {
      const v = metadata[k];
      if (typeof v === 'number') {
        return `${k}: ${v.toLocaleString(undefined, { maximumFractionDigits: 2 })}`;
      }
      return `${k}: ${v}`;
    }).join(', ');
  }

  getFullMetadata(metadata: Record<string, any>): string {
    return JSON.stringify(metadata, null, 2);
  }

  getCategoryKeys(): string[] {
    if (!this.categories?.categories) return [];
    return Object.keys(this.categories.categories);
  }
}
